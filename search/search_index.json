{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Overview","text":"<p>Welcome to Komposer documentation.</p> <p>Komposer is a CLI tool to convert a Docker Compose file into a Kubernetes manifest file so that you can deploy your Docker Compose stack it into a single Kubernetes Pod.</p> <p>This project has been heavly inspired by Kompose.</p>"},{"location":"#why-not-using-kompose","title":"Why not using Kompose","text":"<p>Why not using Kompose instead o creating a new project?</p> <p>The short answer is that Kompose does a slightly different job that what Komposer does:</p> <ul> <li>Kompose is a tool to replicate as is the Docker Compose setup into a Kubernetes cluster</li> <li>Komposer is a tool to deploy Docker Compose setup on Kubernetes for development purposes.</li> </ul> <p>Other than that there are other small differences:</p> <ul> <li>Kompose doesn't create ConfigMaps for services in Docker Compose that load environment variables from a file using the <code>env_file</code> option</li> <li>Kompose doesn't have an option to create an Ingress for a specific service</li> <li>Kompose doesn't give the ability to specify extra Kubernetes items outside the Docker Compose file</li> </ul>"},{"location":"examples/github_actions/","title":"Github Actions","text":"<p>This is an example of how to integrate Komposer in Github Actions.</p> <p>The configuration is divided in three blocks:</p> <ul> <li>building and pushing the Docker image</li> <li>cleaning Komposer's Kubernetes resources previously deployed</li> <li>deploy the new Kubernetes resource generated from Komposer</li> </ul> <p>The example includes also some preliminary steps to setup Pytohn and Google Cloud SDK, they are there for completness but not mandatory to deploy the resources generated by Komposer.</p> <pre><code>name: \"Komposer deploy example\"\n\nenv:\n  SERVICE_NAME: \"service-example\"\n  GCLOUD_SDK_VERSION: \"386.0.0\"\n  PYTHON_VERSION: \"3.10\"\n  POETRY_VERSION: \"1.1.15\"\n  GKE_PROJECT_ID: \"my-project-id\"\n  GKE_CLUSTER: \"my-cluster-name\"\n\non:\n  pull_request:\n\njobs:\n  build-push:\n    runs-on: ubuntu\n    steps:\n      - uses: actions/checkout@v3\n      - name: Build and push\n        run: |\n          sha=${GITHUB_SHA::7}\n          image=${{ env.SERVICE_NAME }}:${sha}\n\n          docker build -t \"$image\" .\n          docker push \"$image\"\n\n  clean-dev-resources:\n    steps:\n      - uses: actions/checkout@v3\n      - name: Authenticate to Google Cloud\n        uses: google-github-actions/auth@v0.8.0\n        with:\n          credentials_json: ${{ secrets.GKE_JSON_KEY }}\n      - name: Set up Cloud SDK\n        uses: google-github-actions/setup-gcloud@v0.6.0\n        with:\n          version: ${{ env.GCLOUD_SDK_VERSION }}\n          project_id: ${{ env.GKE_PROJECT_ID }}\n      - name: Set cluster credentials\n        env:\n          PROJECT_ID: ${{ env.GKE_PROJECT_ID }}\n          GKE_CLUSTER: ${{ env.GKE_CLUSTER }}\n        run: |\n          gcloud container clusters get-credentials \\\n              --project $GKE_PROJECT_ID \\\n              $GKE_CLUSTER\n      - name: Clean up dev resources\n        run: |\n          # Set variables\n          export branch_name=$( echo ${{ github.ref_name }} | tr '[:upper:]' '[:lower:]' | tr -c '[:alnum:]' '-' | sed 's/.$//' )\n          export repository_name=$( echo ${{ github.repository }} | cut -d'/' -f2)\n\n          # Delete resources\n          kubectl delete job -l repository=$repository_name,branch=$branch_name\n          kubectl delete deployment -l repository=$repository_name,branch=$branch_name\n          kubectl delete service -l repository=$repository_name,branch=$branch_name\n          kubectl delete ingress -l repository=$repository_name,branch=$branch_name\n          kubectl delete configmap -l repository=$repository_name,branch=$branch_name\n\n  deploy-dev:\n    needs:\n      - clean-dev-resources\n      - build-push\n    steps:\n      - uses: actions/checkout@v3\n      - name: Authenticate to Google Cloud\n        uses: google-github-actions/auth@v0.8.0\n        with:\n          credentials_json: ${{ secrets.GKE_JSON_KEY }}\n      - name: Set up Cloud SDK\n        uses: google-github-actions/setup-gcloud@v0.6.0\n        with:\n          version: ${{ env.GCLOUD_SDK_VERSION }}\n          project_id: ${{ env.GKE_PROJECT_ID }}\n      - name: Set cluster credentials\n        env:\n          PROJECT_ID: ${{ env.GKE_PROJECT_ID }}\n          GKE_CLUSTER: ${{ env.GKE_CLUSTER }}\n        run: |\n          gcloud container clusters get-credentials \\\n              --project $GKE_PROJECT_ID \\\n              $GKE_CLUSTER\n      - uses: actions/setup-python@v3\n        with:\n          python-version: ${{ env.PYTHON_VERSION }}\n      - name: Cache multiple Pips\n        uses: actions/cache@v3\n        with:\n          path: |\n            ~/.cache/pip\n          key: ${{ runner.os }}-${{ env.PYTHON_VERSION }}-${{ hashFiles('**/poetry.lock') }}\n      - name: install dependencies\n        run: |\n          pip install 'poetry== ${{ env.POETRY_VERSION }}'\n          poetry install\n      - name: Generate dev manifest\n        run: |\n          # Set variables\n          export branch_name=$( echo ${{ github.ref_name }} | tr '[:upper:]' '[:lower:]' | tr -c '[:alnum:]' '-' | sed 's/.$//' )\n          export repository_name=$( echo ${{ github.repository }} | cut -d'/' -f2)\n\n          # Generate dev manifest\n          poetry run komposer \\\n            --repository-name $repository_name \\\n            --branch-name $branch_name \\\n          &gt; dev-deploy-template.yaml\n      - name: Deploy dev manifest\n        run: |\n          # Set variables\n          export branch_name=$( echo ${{ github.ref_name }} | tr '[:upper:]' '[:lower:]' | tr -c '[:alnum:]' '-' | sed 's/.$//' )\n          export repository_name=$( echo ${{ github.repository }} | cut -d'/' -f2)\n          export sha=${GITHUB_SHA::7}\n          export image=\"${{ env.SERVICE_NAME }}:${sha}\"\n\n          # Render the manifest\n          cat dev-deploy-template.yaml | envsubst '${image}' &gt; dev-deploy.yaml\n\n          # Deploy service\n          cat dev-deploy.yaml | kubectl apply -l pre-deploy!=yes -f -\n\n          for i in $(kubectl get deployments -l repository=$repository_name,branch=$branch_name -o name)\n          do\n            kubectl rollout status \"$i\" --timeout=300s\n          done\n</code></pre> <p>Note</p> <p>The branch name is a lowercase kebab  version of the Git's branch name with any slash converted into dashes; this makes the branch name compatible with Kubernetes naming rules .</p>"},{"location":"examples/github_actions/#building-and-pushing-the-image","title":"Building and pushing the image","text":"<p>The first step is to build and push the docker image of your service into the Docker hub:</p> <pre><code>name: \"Komposer deploy example\"\n\nenv:\n  SERVICE_NAME: \"service-example\"\n  GCLOUD_SDK_VERSION: \"386.0.0\"\n  PYTHON_VERSION: \"3.10\"\n  POETRY_VERSION: \"1.1.15\"\n  GKE_PROJECT_ID: \"my-project-id\"\n  GKE_CLUSTER: \"my-cluster-name\"\n\non:\n  pull_request:\n\njobs:\n  build-push:\n    runs-on: ubuntu\n    steps:\n      - uses: actions/checkout@v3\n      - name: Build and push\n        run: |\n          sha=${GITHUB_SHA::7}\n          image=${{ env.SERVICE_NAME }}:${sha}\n\n          docker build -t \"$image\" .\n          docker push \"$image\"\n\n  clean-dev-resources:\n    steps:\n      - uses: actions/checkout@v3\n      - name: Authenticate to Google Cloud\n        uses: google-github-actions/auth@v0.8.0\n        with:\n          credentials_json: ${{ secrets.GKE_JSON_KEY }}\n      - name: Set up Cloud SDK\n        uses: google-github-actions/setup-gcloud@v0.6.0\n        with:\n          version: ${{ env.GCLOUD_SDK_VERSION }}\n          project_id: ${{ env.GKE_PROJECT_ID }}\n      - name: Set cluster credentials\n        env:\n          PROJECT_ID: ${{ env.GKE_PROJECT_ID }}\n          GKE_CLUSTER: ${{ env.GKE_CLUSTER }}\n        run: |\n          gcloud container clusters get-credentials \\\n              --project $GKE_PROJECT_ID \\\n              $GKE_CLUSTER\n      - name: Clean up dev resources\n        run: |\n          # Set variables\n          export branch_name=$( echo ${{ github.ref_name }} | tr '[:upper:]' '[:lower:]' | tr -c '[:alnum:]' '-' | sed 's/.$//' )\n          export repository_name=$( echo ${{ github.repository }} | cut -d'/' -f2)\n\n          # Delete resources\n          kubectl delete job -l repository=$repository_name,branch=$branch_name\n          kubectl delete deployment -l repository=$repository_name,branch=$branch_name\n          kubectl delete service -l repository=$repository_name,branch=$branch_name\n          kubectl delete ingress -l repository=$repository_name,branch=$branch_name\n          kubectl delete configmap -l repository=$repository_name,branch=$branch_name\n\n  deploy-dev:\n    needs:\n      - clean-dev-resources\n      - build-push\n    steps:\n      - uses: actions/checkout@v3\n      - name: Authenticate to Google Cloud\n        uses: google-github-actions/auth@v0.8.0\n        with:\n          credentials_json: ${{ secrets.GKE_JSON_KEY }}\n      - name: Set up Cloud SDK\n        uses: google-github-actions/setup-gcloud@v0.6.0\n        with:\n          version: ${{ env.GCLOUD_SDK_VERSION }}\n          project_id: ${{ env.GKE_PROJECT_ID }}\n      - name: Set cluster credentials\n        env:\n          PROJECT_ID: ${{ env.GKE_PROJECT_ID }}\n          GKE_CLUSTER: ${{ env.GKE_CLUSTER }}\n        run: |\n          gcloud container clusters get-credentials \\\n              --project $GKE_PROJECT_ID \\\n              $GKE_CLUSTER\n      - uses: actions/setup-python@v3\n        with:\n          python-version: ${{ env.PYTHON_VERSION }}\n      - name: Cache multiple Pips\n        uses: actions/cache@v3\n        with:\n          path: |\n            ~/.cache/pip\n          key: ${{ runner.os }}-${{ env.PYTHON_VERSION }}-${{ hashFiles('**/poetry.lock') }}\n      - name: install dependencies\n        run: |\n          pip install 'poetry== ${{ env.POETRY_VERSION }}'\n          poetry install\n      - name: Generate dev manifest\n        run: |\n          # Set variables\n          export branch_name=$( echo ${{ github.ref_name }} | tr '[:upper:]' '[:lower:]' | tr -c '[:alnum:]' '-' | sed 's/.$//' )\n          export repository_name=$( echo ${{ github.repository }} | cut -d'/' -f2)\n\n          # Generate dev manifest\n          poetry run komposer \\\n            --repository-name $repository_name \\\n            --branch-name $branch_name \\\n          &gt; dev-deploy-template.yaml\n      - name: Deploy dev manifest\n        run: |\n          # Set variables\n          export branch_name=$( echo ${{ github.ref_name }} | tr '[:upper:]' '[:lower:]' | tr -c '[:alnum:]' '-' | sed 's/.$//' )\n          export repository_name=$( echo ${{ github.repository }} | cut -d'/' -f2)\n          export sha=${GITHUB_SHA::7}\n          export image=\"${{ env.SERVICE_NAME }}:${sha}\"\n\n          # Render the manifest\n          cat dev-deploy-template.yaml | envsubst '${image}' &gt; dev-deploy.yaml\n\n          # Deploy service\n          cat dev-deploy.yaml | kubectl apply -l pre-deploy!=yes -f -\n\n          for i in $(kubectl get deployments -l repository=$repository_name,branch=$branch_name -o name)\n          do\n            kubectl rollout status \"$i\" --timeout=300s\n          done\n</code></pre>"},{"location":"examples/github_actions/#cleaning-kubernetes-resources","title":"Cleaning Kubernetes resources","text":"<p>Before deploying we need to remove any previously deployed resources by deleting all the resources with the labels matching the branch and repository names:</p> <pre><code>name: \"Komposer deploy example\"\n\nenv:\n  SERVICE_NAME: \"service-example\"\n  GCLOUD_SDK_VERSION: \"386.0.0\"\n  PYTHON_VERSION: \"3.10\"\n  POETRY_VERSION: \"1.1.15\"\n  GKE_PROJECT_ID: \"my-project-id\"\n  GKE_CLUSTER: \"my-cluster-name\"\n\non:\n  pull_request:\n\njobs:\n  build-push:\n    runs-on: ubuntu\n    steps:\n      - uses: actions/checkout@v3\n      - name: Build and push\n        run: |\n          sha=${GITHUB_SHA::7}\n          image=${{ env.SERVICE_NAME }}:${sha}\n\n          docker build -t \"$image\" .\n          docker push \"$image\"\n\n  clean-dev-resources:\n    steps:\n      - uses: actions/checkout@v3\n      - name: Authenticate to Google Cloud\n        uses: google-github-actions/auth@v0.8.0\n        with:\n          credentials_json: ${{ secrets.GKE_JSON_KEY }}\n      - name: Set up Cloud SDK\n        uses: google-github-actions/setup-gcloud@v0.6.0\n        with:\n          version: ${{ env.GCLOUD_SDK_VERSION }}\n          project_id: ${{ env.GKE_PROJECT_ID }}\n      - name: Set cluster credentials\n        env:\n          PROJECT_ID: ${{ env.GKE_PROJECT_ID }}\n          GKE_CLUSTER: ${{ env.GKE_CLUSTER }}\n        run: |\n          gcloud container clusters get-credentials \\\n              --project $GKE_PROJECT_ID \\\n              $GKE_CLUSTER\n      - name: Clean up dev resources\n        run: |\n          # Set variables\n          export branch_name=$( echo ${{ github.ref_name }} | tr '[:upper:]' '[:lower:]' | tr -c '[:alnum:]' '-' | sed 's/.$//' )\n          export repository_name=$( echo ${{ github.repository }} | cut -d'/' -f2)\n\n          # Delete resources\n          kubectl delete job -l repository=$repository_name,branch=$branch_name\n          kubectl delete deployment -l repository=$repository_name,branch=$branch_name\n          kubectl delete service -l repository=$repository_name,branch=$branch_name\n          kubectl delete ingress -l repository=$repository_name,branch=$branch_name\n          kubectl delete configmap -l repository=$repository_name,branch=$branch_name\n\n  deploy-dev:\n    needs:\n      - clean-dev-resources\n      - build-push\n    steps:\n      - uses: actions/checkout@v3\n      - name: Authenticate to Google Cloud\n        uses: google-github-actions/auth@v0.8.0\n        with:\n          credentials_json: ${{ secrets.GKE_JSON_KEY }}\n      - name: Set up Cloud SDK\n        uses: google-github-actions/setup-gcloud@v0.6.0\n        with:\n          version: ${{ env.GCLOUD_SDK_VERSION }}\n          project_id: ${{ env.GKE_PROJECT_ID }}\n      - name: Set cluster credentials\n        env:\n          PROJECT_ID: ${{ env.GKE_PROJECT_ID }}\n          GKE_CLUSTER: ${{ env.GKE_CLUSTER }}\n        run: |\n          gcloud container clusters get-credentials \\\n              --project $GKE_PROJECT_ID \\\n              $GKE_CLUSTER\n      - uses: actions/setup-python@v3\n        with:\n          python-version: ${{ env.PYTHON_VERSION }}\n      - name: Cache multiple Pips\n        uses: actions/cache@v3\n        with:\n          path: |\n            ~/.cache/pip\n          key: ${{ runner.os }}-${{ env.PYTHON_VERSION }}-${{ hashFiles('**/poetry.lock') }}\n      - name: install dependencies\n        run: |\n          pip install 'poetry== ${{ env.POETRY_VERSION }}'\n          poetry install\n      - name: Generate dev manifest\n        run: |\n          # Set variables\n          export branch_name=$( echo ${{ github.ref_name }} | tr '[:upper:]' '[:lower:]' | tr -c '[:alnum:]' '-' | sed 's/.$//' )\n          export repository_name=$( echo ${{ github.repository }} | cut -d'/' -f2)\n\n          # Generate dev manifest\n          poetry run komposer \\\n            --repository-name $repository_name \\\n            --branch-name $branch_name \\\n          &gt; dev-deploy-template.yaml\n      - name: Deploy dev manifest\n        run: |\n          # Set variables\n          export branch_name=$( echo ${{ github.ref_name }} | tr '[:upper:]' '[:lower:]' | tr -c '[:alnum:]' '-' | sed 's/.$//' )\n          export repository_name=$( echo ${{ github.repository }} | cut -d'/' -f2)\n          export sha=${GITHUB_SHA::7}\n          export image=\"${{ env.SERVICE_NAME }}:${sha}\"\n\n          # Render the manifest\n          cat dev-deploy-template.yaml | envsubst '${image}' &gt; dev-deploy.yaml\n\n          # Deploy service\n          cat dev-deploy.yaml | kubectl apply -l pre-deploy!=yes -f -\n\n          for i in $(kubectl get deployments -l repository=$repository_name,branch=$branch_name -o name)\n          do\n            kubectl rollout status \"$i\" --timeout=300s\n          done\n</code></pre> <p>This is necessary because resources can be added, removed or renamed in the Komposer manifest between runs of the CI and the <code>kubectl</code> command doesn't provide a way to perform a full sync of the resources in the cluster compared with the resources in the Komposer's manifest.</p>"},{"location":"examples/github_actions/#deploy-the-komposer-manifest","title":"Deploy the Komposer manifest","text":"<p>The last section, generating the Kubernetes manifest with Komposer and deploying the resources in the Kubernetes cluster.</p> <p>After installing Python and setting up Google Cloud SDK we generate the manifest's template with Komposer:</p> <pre><code>name: \"Komposer deploy example\"\n\nenv:\n  SERVICE_NAME: \"service-example\"\n  GCLOUD_SDK_VERSION: \"386.0.0\"\n  PYTHON_VERSION: \"3.10\"\n  POETRY_VERSION: \"1.1.15\"\n  GKE_PROJECT_ID: \"my-project-id\"\n  GKE_CLUSTER: \"my-cluster-name\"\n\non:\n  pull_request:\n\njobs:\n  build-push:\n    runs-on: ubuntu\n    steps:\n      - uses: actions/checkout@v3\n      - name: Build and push\n        run: |\n          sha=${GITHUB_SHA::7}\n          image=${{ env.SERVICE_NAME }}:${sha}\n\n          docker build -t \"$image\" .\n          docker push \"$image\"\n\n  clean-dev-resources:\n    steps:\n      - uses: actions/checkout@v3\n      - name: Authenticate to Google Cloud\n        uses: google-github-actions/auth@v0.8.0\n        with:\n          credentials_json: ${{ secrets.GKE_JSON_KEY }}\n      - name: Set up Cloud SDK\n        uses: google-github-actions/setup-gcloud@v0.6.0\n        with:\n          version: ${{ env.GCLOUD_SDK_VERSION }}\n          project_id: ${{ env.GKE_PROJECT_ID }}\n      - name: Set cluster credentials\n        env:\n          PROJECT_ID: ${{ env.GKE_PROJECT_ID }}\n          GKE_CLUSTER: ${{ env.GKE_CLUSTER }}\n        run: |\n          gcloud container clusters get-credentials \\\n              --project $GKE_PROJECT_ID \\\n              $GKE_CLUSTER\n      - name: Clean up dev resources\n        run: |\n          # Set variables\n          export branch_name=$( echo ${{ github.ref_name }} | tr '[:upper:]' '[:lower:]' | tr -c '[:alnum:]' '-' | sed 's/.$//' )\n          export repository_name=$( echo ${{ github.repository }} | cut -d'/' -f2)\n\n          # Delete resources\n          kubectl delete job -l repository=$repository_name,branch=$branch_name\n          kubectl delete deployment -l repository=$repository_name,branch=$branch_name\n          kubectl delete service -l repository=$repository_name,branch=$branch_name\n          kubectl delete ingress -l repository=$repository_name,branch=$branch_name\n          kubectl delete configmap -l repository=$repository_name,branch=$branch_name\n\n  deploy-dev:\n    needs:\n      - clean-dev-resources\n      - build-push\n    steps:\n      - uses: actions/checkout@v3\n      - name: Authenticate to Google Cloud\n        uses: google-github-actions/auth@v0.8.0\n        with:\n          credentials_json: ${{ secrets.GKE_JSON_KEY }}\n      - name: Set up Cloud SDK\n        uses: google-github-actions/setup-gcloud@v0.6.0\n        with:\n          version: ${{ env.GCLOUD_SDK_VERSION }}\n          project_id: ${{ env.GKE_PROJECT_ID }}\n      - name: Set cluster credentials\n        env:\n          PROJECT_ID: ${{ env.GKE_PROJECT_ID }}\n          GKE_CLUSTER: ${{ env.GKE_CLUSTER }}\n        run: |\n          gcloud container clusters get-credentials \\\n              --project $GKE_PROJECT_ID \\\n              $GKE_CLUSTER\n      - uses: actions/setup-python@v3\n        with:\n          python-version: ${{ env.PYTHON_VERSION }}\n      - name: Cache multiple Pips\n        uses: actions/cache@v3\n        with:\n          path: |\n            ~/.cache/pip\n          key: ${{ runner.os }}-${{ env.PYTHON_VERSION }}-${{ hashFiles('**/poetry.lock') }}\n      - name: install dependencies\n        run: |\n          pip install 'poetry== ${{ env.POETRY_VERSION }}'\n          poetry install\n      - name: Generate dev manifest\n        run: |\n          # Set variables\n          export branch_name=$( echo ${{ github.ref_name }} | tr '[:upper:]' '[:lower:]' | tr -c '[:alnum:]' '-' | sed 's/.$//' )\n          export repository_name=$( echo ${{ github.repository }} | cut -d'/' -f2)\n\n          # Generate dev manifest\n          poetry run komposer \\\n            --repository-name $repository_name \\\n            --branch-name $branch_name \\\n          &gt; dev-deploy-template.yaml\n      - name: Deploy dev manifest\n        run: |\n          # Set variables\n          export branch_name=$( echo ${{ github.ref_name }} | tr '[:upper:]' '[:lower:]' | tr -c '[:alnum:]' '-' | sed 's/.$//' )\n          export repository_name=$( echo ${{ github.repository }} | cut -d'/' -f2)\n          export sha=${GITHUB_SHA::7}\n          export image=\"${{ env.SERVICE_NAME }}:${sha}\"\n\n          # Render the manifest\n          cat dev-deploy-template.yaml | envsubst '${image}' &gt; dev-deploy.yaml\n\n          # Deploy service\n          cat dev-deploy.yaml | kubectl apply -l pre-deploy!=yes -f -\n\n          for i in $(kubectl get deployments -l repository=$repository_name,branch=$branch_name -o name)\n          do\n            kubectl rollout status \"$i\" --timeout=300s\n          done\n</code></pre> <p>Then we render the manifest by substituting the variables, in this case the Docker image's name, deploy it and waiting for the rollout to finish:</p> <pre><code>name: \"Komposer deploy example\"\n\nenv:\n  SERVICE_NAME: \"service-example\"\n  GCLOUD_SDK_VERSION: \"386.0.0\"\n  PYTHON_VERSION: \"3.10\"\n  POETRY_VERSION: \"1.1.15\"\n  GKE_PROJECT_ID: \"my-project-id\"\n  GKE_CLUSTER: \"my-cluster-name\"\n\non:\n  pull_request:\n\njobs:\n  build-push:\n    runs-on: ubuntu\n    steps:\n      - uses: actions/checkout@v3\n      - name: Build and push\n        run: |\n          sha=${GITHUB_SHA::7}\n          image=${{ env.SERVICE_NAME }}:${sha}\n\n          docker build -t \"$image\" .\n          docker push \"$image\"\n\n  clean-dev-resources:\n    steps:\n      - uses: actions/checkout@v3\n      - name: Authenticate to Google Cloud\n        uses: google-github-actions/auth@v0.8.0\n        with:\n          credentials_json: ${{ secrets.GKE_JSON_KEY }}\n      - name: Set up Cloud SDK\n        uses: google-github-actions/setup-gcloud@v0.6.0\n        with:\n          version: ${{ env.GCLOUD_SDK_VERSION }}\n          project_id: ${{ env.GKE_PROJECT_ID }}\n      - name: Set cluster credentials\n        env:\n          PROJECT_ID: ${{ env.GKE_PROJECT_ID }}\n          GKE_CLUSTER: ${{ env.GKE_CLUSTER }}\n        run: |\n          gcloud container clusters get-credentials \\\n              --project $GKE_PROJECT_ID \\\n              $GKE_CLUSTER\n      - name: Clean up dev resources\n        run: |\n          # Set variables\n          export branch_name=$( echo ${{ github.ref_name }} | tr '[:upper:]' '[:lower:]' | tr -c '[:alnum:]' '-' | sed 's/.$//' )\n          export repository_name=$( echo ${{ github.repository }} | cut -d'/' -f2)\n\n          # Delete resources\n          kubectl delete job -l repository=$repository_name,branch=$branch_name\n          kubectl delete deployment -l repository=$repository_name,branch=$branch_name\n          kubectl delete service -l repository=$repository_name,branch=$branch_name\n          kubectl delete ingress -l repository=$repository_name,branch=$branch_name\n          kubectl delete configmap -l repository=$repository_name,branch=$branch_name\n\n  deploy-dev:\n    needs:\n      - clean-dev-resources\n      - build-push\n    steps:\n      - uses: actions/checkout@v3\n      - name: Authenticate to Google Cloud\n        uses: google-github-actions/auth@v0.8.0\n        with:\n          credentials_json: ${{ secrets.GKE_JSON_KEY }}\n      - name: Set up Cloud SDK\n        uses: google-github-actions/setup-gcloud@v0.6.0\n        with:\n          version: ${{ env.GCLOUD_SDK_VERSION }}\n          project_id: ${{ env.GKE_PROJECT_ID }}\n      - name: Set cluster credentials\n        env:\n          PROJECT_ID: ${{ env.GKE_PROJECT_ID }}\n          GKE_CLUSTER: ${{ env.GKE_CLUSTER }}\n        run: |\n          gcloud container clusters get-credentials \\\n              --project $GKE_PROJECT_ID \\\n              $GKE_CLUSTER\n      - uses: actions/setup-python@v3\n        with:\n          python-version: ${{ env.PYTHON_VERSION }}\n      - name: Cache multiple Pips\n        uses: actions/cache@v3\n        with:\n          path: |\n            ~/.cache/pip\n          key: ${{ runner.os }}-${{ env.PYTHON_VERSION }}-${{ hashFiles('**/poetry.lock') }}\n      - name: install dependencies\n        run: |\n          pip install 'poetry== ${{ env.POETRY_VERSION }}'\n          poetry install\n      - name: Generate dev manifest\n        run: |\n          # Set variables\n          export branch_name=$( echo ${{ github.ref_name }} | tr '[:upper:]' '[:lower:]' | tr -c '[:alnum:]' '-' | sed 's/.$//' )\n          export repository_name=$( echo ${{ github.repository }} | cut -d'/' -f2)\n\n          # Generate dev manifest\n          poetry run komposer \\\n            --repository-name $repository_name \\\n            --branch-name $branch_name \\\n          &gt; dev-deploy-template.yaml\n      - name: Deploy dev manifest\n        run: |\n          # Set variables\n          export branch_name=$( echo ${{ github.ref_name }} | tr '[:upper:]' '[:lower:]' | tr -c '[:alnum:]' '-' | sed 's/.$//' )\n          export repository_name=$( echo ${{ github.repository }} | cut -d'/' -f2)\n          export sha=${GITHUB_SHA::7}\n          export image=\"${{ env.SERVICE_NAME }}:${sha}\"\n\n          # Render the manifest\n          cat dev-deploy-template.yaml | envsubst '${image}' &gt; dev-deploy.yaml\n\n          # Deploy service\n          cat dev-deploy.yaml | kubectl apply -l pre-deploy!=yes -f -\n\n          for i in $(kubectl get deployments -l repository=$repository_name,branch=$branch_name -o name)\n          do\n            kubectl rollout status \"$i\" --timeout=300s\n          done\n</code></pre>"},{"location":"getting_started/architecture/","title":"Architecture","text":"<p>The architecture of how Komposer translates the Docker Compose file into a Kubernetes manifest is very simple and intuitive.</p> <p>For each service defined in the Docker Compose file, Komposer generates a Kubernetes manifest with:</p> <ul> <li>a unique Kubernetes ConfigMap for each unique set of <code>environment</code> or <code>env_file</code> keys in the Docker Compose file</li> <li>a single Kubernetes Pod with one container for each Docker compose service</li> <li>a Kubernetes Service for each Docker Compose service pointint to the relative container in the Kubernetes Pod</li> <li>when using the <code>--ingress-for-service</code> CLI argument, a Kubernetes Ingress pointing to a Kubernetes Service</li> </ul> <p>Below a diagram or the translation's architecture.</p> graph LR     subgraph docker_compose[Docker Compose]         docker_service[Service]     end      subgraph kubernetes[Kubernetes]         k8s_configmap_service[ConfigMap]          subgraph pod[Pod]             k8s_container[Container]         end          k8s_service[Service]         k8s_ingress_service[Ingress]     end      docker_service -...-&gt; k8s_ingress_service     docker_service ----&gt; k8s_service     docker_service ----&gt; k8s_configmap_service     docker_service ----&gt; k8s_container  <p>This is applied to all the services in the Docker Compose file except that only one Kubernetes Ingress can be created for only one Docker Compose service.</p> <p>During the translation Komposer substitute the <code>KOMPOSER_*</code> environment variables before render the Kubernetes manifest; see the Environment Variables section for the whole list of available variables.</p>"},{"location":"getting_started/basic_configuration/","title":"Basic configuration","text":""},{"location":"getting_started/basic_configuration/#basic-docker-compose-file","title":"Basic Docker Compose file","text":"<p>Lets start by creating a basic Docker Compose file with a single service and a Redis dependency:</p> <pre><code>version: \"3.9\"\nservices:\n  web:\n    image: mendhak/http-https-echo\n    ports:\n      - \"8443\"\n    links:\n      - redis\n  redis:\n    image: redis\n    ports:\n      - \"6379\"\n</code></pre> <p>When starting the Docker Compose stack it will create two services, <code>web</code> and <code>redis</code> with they respective ports:</p> <pre><code>$ docker compose up -d\n$ docker compose ps\nNAME                COMMAND                  SERVICE             STATUS              PORTS\nkomposer-redis-1    \"docker-entrypoint.s\u2026\"   redis               running             0.0.0.0:56761-&gt;6379/tcp\nkomposer-web-1      \"docker-entrypoint.s\u2026\"   web                 running             0.0.0.0:57210-&gt;8443/tcp\n</code></pre> <p>We are ready now to convert this Docker Compose stack into Kubernetes.</p>"},{"location":"getting_started/basic_configuration/#generating-the-kubernetes-manifest","title":"Generating the Kubernetes manifest","text":"<p>Lets generate a basic Kubernetes manifest from the Docker Compose file above:</p> <pre><code>$ komposer \\\n  --repository-name komposer \\\n  --branch-name docs-example \\\n&gt; manifest.yml\n</code></pre> <p>give us this manifest:</p> <pre><code>apiVersion: v1\nkind: List\nitems:\n  - apiVersion: apps/v1\n    kind: Deployment\n    metadata:\n      name: default-komposer-docs-example\n      annotations: null\n      labels:\n        branch: docs-example\n        repository: komposer\n    spec:\n      replicas: 1\n      selector:\n        matchLabels:\n          branch: docs-example\n          repository: komposer\n      template:\n        metadata:\n          annotations: null\n          labels:\n            branch: docs-example\n            repository: komposer\n        spec:\n          serviceAccountName: null\n          containers:\n            - args: null\n              env: []\n              image: mendhak/http-https-echo\n              imagePullPolicy: IfNotPresent\n              name: web\n              ports:\n                - containerPort: 8443\n                  hostPort: null\n            - args: null\n              env: []\n              image: redis\n              imagePullPolicy: IfNotPresent\n              name: redis\n              ports:\n                - containerPort: 6379\n                  hostPort: null\n          hostAliases:\n            - hostnames:\n                - web\n                - redis\n              ip: 127.0.0.1\n  - apiVersion: v1\n    kind: Service\n    metadata:\n      name: default-komposer-docs-example-web\n      annotations: null\n      labels:\n        branch: docs-example\n        repository: komposer\n    spec:\n      ports:\n        - name: \"8443\"\n          port: 8443\n          targetPort: 8443\n      selector:\n        branch: docs-example\n        repository: komposer\n  - apiVersion: v1\n    kind: Service\n    metadata:\n      name: default-komposer-docs-example-redis\n      annotations: null\n      labels:\n        branch: docs-example\n        repository: komposer\n    spec:\n      ports:\n        - name: \"6379\"\n          port: 6379\n          targetPort: 6379\n      selector:\n        branch: docs-example\n        repository: komposer\n</code></pre> <p>The manifest contains one single pod with two containers, <code>web</code> and <code>redis</code>, as a single deployment and two services.</p> <p>The manifest can be used as is to deploy the resources on Kubernetes:</p> <pre><code>$ kubectl apply -f manifest.yml\n</code></pre>"},{"location":"getting_started/basic_configuration/#adding-an-ingress","title":"Adding an ingress","text":"<p>If you need a Kubernetes Ingress resource pointing to a Docker Compose service just use the <code>--ingress-for-service</code> CLI argument:</p> <pre><code>$ komposer \\\n  --repository-name komposer \\\n  --branch-name docs-example \\\n  --ingress-for-service web \\\n&gt; manifest.yml\n</code></pre> <p>which will generate the same Kubernetes manifest above plus an Ingress resource:</p> <pre><code>- apiVersion: networking.k8s.io/v1\n  kind: Ingress\n  metadata:\n    name: default-komposer-docs-example-web\n    annotations:\n      cert-manager.io/cluster-issuer: letsencrypt-prod\n    labels:\n      branch: docs-example\n      repository: komposer\n  spec:\n    ingressClassName: nginx-internal\n    tls: null\n    rules:\n      - host: web.default-komposer-docs-example.svc.cluster.local\n        http:\n          paths:\n            - backend:\n                service:\n                  name: default-komposer-docs-example-web\n                  port:\n                    number: 8443\n              path: /\n              pathType: Prefix\n</code></pre>"},{"location":"getting_started/basic_configuration/#limitations","title":"Limitations","text":"<ul> <li>only one Kubernetes Ingress can be defined for a service, generating more than one Kubernetes Ingress is not supported yet</li> <li>port mapping defined in Docker Compose file are not supported, this is a limitation imposed by the different networking between Docker Compose and a Kubernetes Pod</li> </ul>"},{"location":"getting_started/install/","title":"Install","text":"<p>To install Komposer just run:</p> <pre><code>$ pip install komposer\n</code></pre> <p>This will provide a <code>komposer</code> command in you shell:</p> <pre><code>$ komposer --help\n</code></pre>"},{"location":"usage/cli_arguments/","title":"CLI Arguments","text":""},{"location":"usage/cli_arguments/#mandatory","title":"Mandatory","text":""},{"location":"usage/cli_arguments/#-repository-name-r","title":"--repository-name, -r","text":"<p>Name of the repository in lowercase kebab format where the system will be deployed.</p>"},{"location":"usage/cli_arguments/#-branch-name-r","title":"--branch-name, -r","text":"<p>Name of the branch in lowercase kebab format from where the system will be deployed.</p>"},{"location":"usage/cli_arguments/#optional","title":"Optional","text":""},{"location":"usage/cli_arguments/#-compose-file-f","title":"--compose-file, -f","text":"<p>Specify the filename of the Docker Compose file to use. Default is <code>docker-compose.yml</code>.</p>"},{"location":"usage/cli_arguments/#-project-name-p","title":"--project-name, -p","text":"<p>Name of the project in lowercase kebab format to be used as prefix in the name of the Kubernetes resources ; usually is same as the company's name.</p>"},{"location":"usage/cli_arguments/#-ingressfor-service","title":"--ingress\u2013for-service","text":"<p>If set, creates a new ingress for the given service present in the Docker Compose file.</p>"},{"location":"usage/cli_arguments/#-extra-manifest","title":"--extra-manifest","text":"<p>Path to the filename containing extra items to be bundled into the generater Kubernetes manifest. The format of the file can be either:</p> <ul> <li>a single Kubernetes resource</li> <li>a YAML multidocument</li> <li>a Kubernetes List item is defined as:</li> </ul> <pre><code>apiVersion: v1\nkind: List\nitems: [...]\n</code></pre> <p>It can be used multiple times to add more than one extra manifest.</p>"},{"location":"usage/cli_arguments/#-default-image","title":"--default-image","text":"<p>The default image name to be used when no value is set in the Docker Compose for the <code>image</code> attribute of a service. Default is <code>${IMAGE}</code></p>"},{"location":"usage/cli_arguments/#-ingress-tls-file","title":"--ingress-tls-file","text":"<p>Path to the file which contains the configuration fragment for the <code>spec.tls</code> section of an Ingress Kubernetes resource.</p>"},{"location":"usage/cli_arguments/#-ingress-domain","title":"--ingress-domain","text":"<p>The top level domain to be used in the ingress' hosts section of the Kubernetes resource.</p>"},{"location":"usage/cli_arguments/#-deployment-annotations-file","title":"--deployment-annotations-file","text":"<p>File containing the annotations to be added to the Kuberneted Deployment resource.</p>"},{"location":"usage/cli_arguments/#-deployment-service-account-name","title":"--deployment-service-account-name","text":"<p>The service account name to be used in the Kubernetes Deployment resource if any.</p>"},{"location":"usage/env_variables/","title":"Environment viariables","text":"<p>Komposer provides some environment variables that can be used in your</p>"},{"location":"usage/env_variables/#komposer_ingress_domain","title":"KOMPOSER_INGRESS_DOMAIN","text":"<p>This variable will be set to the value of the <code>--ingress-domain</code> CLI option, or to the default value if not pset explicitly.</p> <p>An example of how to use this environment variable in an manifest file:</p> <pre><code>- apiVersion: networking.k8s.io/v1\n  kind: Ingress\n  spec:\n    ingressClassName: nginx-internal\n    rules:\n      - host: api.repository-name-branch-name.${KOMPOSER_INGRESS_DOMAIN}\n        http:\n          paths:\n            - backend:\n                service:\n                  name: repository-name-branch-name-api\n                  port:\n                    number: 8080\n              path: /\n              pathType: Prefix\n    tls:\n      - hosts:\n          - api.repository-name-branch-name.${KOMPOSER_INGRESS_DOMAIN}\n        secretName: app-tls-cert\n</code></pre>"},{"location":"usage/env_variables/#komposer_service_prefix","title":"KOMPOSER_SERVICE_PREFIX","text":"<p>Variable that holds the computed service prefix.</p> <p>The service prefix is the concatenation of <code>[&lt;project-name&gt;-]&lt;repository-name&gt;-&lt;branch-name&gt;</code>. i.e. <code>my-repository-my-branch</code> or <code>my-project-my-resository-my-branch</code>.</p> <p>This is useful to be able to reference services in extra manifest files because the prefix is not known until the manifest is generated.</p> <p>In this example, an extra manifest containing a job to migrate a database with Alembic points to a service using the <code>KOMPOSER_SERVICE_PREFIX</code> environment variable:</p> <pre><code>apiVersion: batch/v1\nkind: Job\nmetadata:\n  name: db-migrations\nspec:\n  template:\n    spec:\n      restartPolicy: OnFailure\n      containers:\n        - name: db-migrations\n          imagePullPolicy: IfNotPresent\n          image: ${IMAGE}\n          args:\n            - alembic\n            - upgrade\n            - head\n          env:\n            - name: DATABASE_URL\n              value: postgresql://${KOMPOSER_SERVICE_PREFIX}-postgres/database\n</code></pre> <p>See that the <code>KOMPOSER_SERVICE_PREFIX</code> is used to provide the correct prefix to the <code>postgres</code> services at runtime.</p>"}]}